

import matplotlib.pyplot as plt
from matplotlib import markers
from scipy.sparse import random_array

  Einfacher Plot
x = [1,2,3,4,5,6,7,8,9,10]
y = [26, 6, 2, 5, 23, 65, 3, 1, 43, 7]
y2 = [2, 65, 54, 6, 43, 23, 3, 1, 4, 72]
 plt.plot(x, y) -  plt.plot(x,y) показывает координаты
 plt.show() -  plt.show() показывает график
 
    маркеры: величина, цвет и яркость
 plt.plot(x,y, marker = "o", markersize = 15, markerfacecolor = "g" )
 plt.show()
  plt.plot(x,y,linestyle = "dotted", color = "g", linewidth = "3")
  plt.show()
 
  font_achsen = {'family': 'serif', 'color': 'red', 'size': '12'}    Шрифт для подписей осей (красный, 12px, с засечками)
  font_titel = {'family': 'serif', 'color': 'green', 'size': '20'}    Шрифт для заголовка (зелёный, 20px, с засечками)
 
  plt.plot(x, y, linestyle='dotted', color='r', linewidth="2", label="Daten 2022")    Построение первой линии (точечная, красная, толщина 2)
  plt.plot(x, y2, linestyle='dashed', color='b', linewidth="1", label="Daten 2021")    Построение второй линии (пунктирная, синяя, толщина 1)
 
  plt.xlabel('Anzahl der Kunden', fontdict=font_achsen)    Подпись оси X: "Количество клиентов"
  plt.ylabel('Ausgegebenes Geld', fontdict=font_achsen)    Подпись оси Y: "Потраченные деньги"
 
  plt.title('Kundendaten', loc='center', fontdict=font_titel)    Заголовок графика: "Данные о клиентах", по центру
 
  plt.legend(loc='upper left')    Легенда (обозначения линий) в верхнем левом углу
 
  plt.show()    Отображение графика

  SUBPLOTS

  Когда это полезно?
  Сравнение данных (например, динамика продаж за разные годы).
  Отображение нескольких метрик на отдельных графиках.
  Разные стили визуализации (гистограммы, линии, точки и т. д.).
  Если бы мы просто использовали plt.plot() без subplot(), оба графика наложились бы друг на друга.




  plt.subplot(1, 2, 1)    Создаём первый график (1 строка, 2 столбца, 1-й график)
  plt.plot(x, y, linestyle='dotted', color='r', linewidth="2", label="Daten 2022")    Построение первой линии (точечная, красная, толщина 2)
  plt.title("Daten 2022")    Заголовок для первого графика
 
  plt.subplot(1, 2, 2)    Создаём второй график (1 строка, 2 столбца, 2-й график)
  plt.plot(x, y2, linestyle='dashed', color='b', linewidth="1", label="Daten 2021")    Построение второй линии (пунктирная, синяя, толщина 1)
  plt.title("Daten 2021")    Заголовок для второго графика
 
  plt.suptitle('Kundendaten')    Общий заголовок для всех графиков
  plt.show()    Отображение графиков

  1.5.3. Streudiagramme erstellen

  Что делает plt.scatter()?
  Функция plt.scatter() используется для создания диаграммы рассеяния (scatter plot), где каждая точка представляется в виде отдельного маркера.
  Это удобно, когда нужно показать зависимость двух переменных.

  plt.scatter(x, y, alpha=0.3, s=40, color='r', label="Daten 2022")
  Создаём диаграмму рассеяния (scatter plot) для y
  alpha=0.3 → прозрачность точек (30%)
  s=40 → размер точек
  color='r' → красные точки
  linewidth="2" → толщина границы точек (не влияет на scatter)
  label="Daten 2022" → метка для легенды

  plt.scatter(x, y2, alpha=0.6, s=15, color='b', label="Daten 2021")
    Создаём вторую диаграмму рассеяния для y2
    alpha=0.6 → прозрачность 60%
    s=15 → меньший размер точек
    color='b' → синие точки
    linewidth="1" → толщина границы (не влияет)
    label="Daten 2021" → метка для легенды
 
  plt.legend(loc='upper left')    Добавляем легенду в верхний левый угол
  plt.show()    Отображаем график

  Histogramme

  Нормальное распределение — это наиболее распространённое распределение данных в природе, статистике и машинном обучении.
  Оно имеет колоколообразную симметричную форму и определяется двумя параметрами:
  Среднее (μ, "му") → центр распределения (где данные концентрируются).
  Стандартное отклонение (σ, "сигма") → насколько данные разбросаны относительно среднего.

import numpy as np
import matplotlib.pyplot as plt    Добавляем импорт для plt

  random_arrays = np.random.normal(170, 10, 250)    Генерируем 250 случайных значений с нормальным распределением (среднее=170, std=10)
 
  plt.hist(random_arrays, bins=20, color='blue', edgecolor='black')    Создаём гистограмму с 20 столбцами
  plt.xlabel("Рост (см)")    Подпись оси X
  plt.ylabel("Частота")    Подпись оси Y
  plt.title("Распределение роста")    Заголовок графика
  plt.show()    Показываем график

  1.5.5. Kuchendiagramme

  y3 = [12, 53, 34, 23]    Данные для круговой диаграммы (количество покупок)
  mylabels = ['Schoko', 'Eis', 'Apfel', 'Pommes']    Подписи для сегментов (названия продуктов)
 
  plt.pie(y3, labels=mylabels)    Создаём круговую диаграмму с заданными значениями и подписями
 
  plt.legend(title='Meistgekauft', prop={'size': 5}, loc='lower right')
    Добавляем легенду:
    title='Meistgekauft' → заголовок легенды
    prop={'size': 5} → размер шрифта в легенде (очень маленький, можно увеличить)
    loc='lower right' → размещение в правом нижнем углу
 
  plt.show()    Отображаем диаграмму

  1.6. Algorithmen-Komplexität

  Факториал

def factorial ( n ):
    product = 1
    for i in range ( n ):
        product = product * (i + 1)
    return  product

print(factorial(5))   120

def factorial_2 ( n ):
    if n == 0:
        return 1
    else:
        return n * (factorial(n-1))

print(factorial_2(5))   120



import timeit
import math

print(timeit.timeit("math.factorial(50)", setup="import math", number=10000))



  1.6.2. Arten von Komplexität

  Im Allgemeinen unterscheidet man hier zwischen zwei Arten von
  Komplexität:
  • Die Platzkomplexität
  • Die Zeitkomplexität

  Konstante Komplexität O(1)

def constant_algo ( items ):
    result = items[3]
    print(result)

constant_algo([2,3,4,5,6])   5

  Lineare Komplexität O(n)

  Praktisch
  heißt das, wenn wir die Anzahl der Eingabeelemente verdoppeln,
  verdoppelt sich auch der Aufwand des Algorithmus

liste = [4,1,75,23,7,2,1,97,23,6]

def linear_algo ( items ):
    for item in items:
        if item == 6:
            print(items.index(item))

linear_algo( liste )   9

  Quadratische Komplexität - ...dann heißt das, dass die Laufzeit mit dem Quadrat der Anzahl
  der Eingabeelemente wächst

  Logarithmische Komplexität O(log(n))

d = log2(n)   На сколько шагов дробится число чтобы найти его единичные варианты

  Quasilineare Komplexität O(nlog(n))

O(n log(n))

Алгоритмическая сложность в программировании
Алгоритмическая сложность (или вычислительная сложность) — это способ оценки эффективности алгоритма.
Она показывает, как изменяется время работы (или потребление памяти) алгоритма при увеличении размера входных данных.

1. Почему это важно?
Когда вы пишете код, вам важно, чтобы он работал быстро и эффективно. Особенно на больших входных данных.
Например:

Поиск в базе из 10 записей можно сделать любым способом — даже неэффективным.
Но если записей 1 000 000 000, неудачный алгоритм может выполняться часы, а хороший — за доли секунды!
Чтобы оценивать сложность, используют Big O (О-большое).

2. Основные классы сложности (Big O)
O(1) — Константная сложность (очень быстро!)
Время работы не зависит от размера данных.
Пример: доступ к элементу массива по индексу.


arr = [10, 20, 30, 40, 50]
print(arr[2])    O(1)
Неважно, 10 элементов или 10 млн — операция выполняется за одно и то же время.

O(log N) — Логарифмическая сложность (быстро)
Время работы растёт медленно, даже если данные увеличиваются в разы.
Пример: бинарный поиск (поиск в отсортированном массиве).


import bisect
arr = [1, 3, 5, 7, 9, 11, 13, 15]
index = bisect.bisect_left(arr, 7)    O(log N)
Если данных 1 000 000, бинарный поиск сделает ~20 шагов вместо 1 млн.
Если 1 000 000 000, всего ~30 шагов!
O(N) — Линейная сложность (нормально)
Время выполнения пропорционально количеству данных.
Пример: поиск элемента в неотсортированном массиве.


arr = [4, 2, 9, 7, 3]
for x in arr:
    if x == 9:
        print("Найдено!")    O(N)
Чем больше данных, тем дольше работает алгоритм.

O(N log N) — Квазилинейная сложность (приемлемо)
Так работают быстрые сортировки (например, QuickSort, MergeSort).


arr = [4, 2, 9, 7, 3]
arr.sort()    O(N log N)
Если N = 1 000 000, сложность будет ~6 000 000 (быстрее, чем O(N²)).

O(N²) — Квадратичная сложность (медленно)
Производится много вложенных операций.
Пример: два вложенных цикла (поиск всех пар в массиве).


arr = [4, 2, 9, 7, 3]
for i in range(len(arr)):
    for j in range(len(arr)):
        print(arr[i], arr[j])    O(N²)
Если N = 1 000 000, то 1 000 000 000 000 итераций! Это очень медленно.

O(2^N) — Экспоненциальная сложность (очень медленно)
Каждое увеличение N в два раза увеличивает время работы.
Пример: рекурсивный перебор всех подмножеств множества.


def subset_sum(arr, target, index=0, current_sum=0):
    if index == len(arr):
        return current_sum == target
    return (subset_sum(arr, target, index + 1, current_sum + arr[index]) or
            subset_sum(arr, target, index + 1, current_sum))

arr = [1, 2, 3, 4]
print(subset_sum(arr, 5))    O(2^N)
При N = 30 такой алгоритм может выполняться годы.

O(N!) — Факториальная сложность (ужасно медленно)
Пример: перебор всех возможных перестановок.


from itertools import permutations
arr = [1, 2, 3]
perms = list(permutations(arr))    O(N!)
Если N = 10, будет 3 628 800 вариантов!
Если N = 20, уже 2 432 902 008 176 640 000 😱



















