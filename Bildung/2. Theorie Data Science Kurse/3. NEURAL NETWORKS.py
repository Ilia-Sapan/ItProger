
# 1. –ù–µ–π—Ä–æ–Ω –∫–∞–∫ –±–∞–∑–æ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç
# –ì–ª–∞–≤–Ω–∞—è –∏–¥–µ—è: –Ω–µ–π—Ä–æ–Ω –ø–æ–ª—É—á–∞–µ—Ç –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ,
# –≤—ã—á–∏—Å–ª—è–µ—Ç –∏—Ö –≤–∑–≤–µ—à–µ–Ω–Ω—É—é —Å—É–º–º—É –∏ –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç —á–µ—Ä–µ–∑ —Ñ—É–Ω–∫—Ü–∏—é –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Å–∏–≥–º–æ–∏–¥—É)

import numpy as np

def sigmoid ( x ) :
    return 1 / ( 1 + np.exp ( - x ) )

# –ü—Ä–∏–º–µ—Ä –ø—Ä–æ—Å—Ç–æ–≥–æ –Ω–µ–π—Ä–æ–Ω–∞

inputs = np.array ( [0.5, - 0.2, 0.1 ] )

weights = np.array( [0.4, 0.8, - 0.5 ] )

# –í–∑–≤–µ—à–µ–Ω–Ω–∞—è —Å—É–º–º–∞ –∏ –∞–∫—Ç–∏–≤–∞—Ü–∏—è

output_neuron = sigmoid( np.dot (inputs, weights))

print(f'–í—ã—Ö–æ–¥ –Ω–µ–π—Ä–æ–Ω–∞ : {output_neuron}')

# 2. –ü–µ—Ä–µ–¥–∞—á–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ (Forward Propagation)

# –ò–¥–µ—è: –î–∞–Ω–Ω—ã–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ –ø—Ä–æ—Ö–æ–¥—è—Ç —á–µ—Ä–µ–∑ —Å–ª–æ–∏ —Å–µ—Ç–∏: –≤—Ö–æ–¥–Ω–æ–π —Å–ª–æ–π > —Å–∫—Ä—ã—Ç—ã–π —Å–ª–æ–π > –≤—ã—Ö–æ–¥–Ω–æ–π —Å–ª–æ–π
# –ù–∞ –∫–∞–∂–¥–æ–º —ç—Ç–∞–ø–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —É–º–Ω–æ–∂–µ–Ω–∏–µ –≤–µ—Å–∞ –∏ —Ñ—É–Ω–∫—Ü–∏—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏

# –ü—Ä–∏–º–µ—Ä –ø—Ä—è–º–æ–≥–æ –ø—Ä–æ—Ö–æ–¥–∞ —á–µ—Ä–µ–∑ –æ–¥–∏–Ω —Å–∫—Ä—ã—Ç—ã–π —Å–ª–æ–π

input_vector = np.array([0.6, 0.1, 0.8])

# –°–ª—É—á–∞–π–Ω–æ –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –≤–µ—Å–∞

w_input_hidden = np.random.uniform(-0.5, 0.5, (4,3)) # 4 –Ω–µ–π—Ä–æ–Ω–∞ —Å–∫—Ä—ã—Ç–æ–≥–æ —Å–ª–æ—è, 3 –≤—Ö–æ–¥–∞
w_hidden_output = np.random.uniform(-0.5, 0.5, (2,4)) # 2 –Ω–µ–π—Ä–æ–Ω–∞ –≤—ã—Ö–æ–¥–Ω–æ–≥–æ —Å–ª–æ—è, 4 —Å–∫—Ä—ã—Ç—ã—Ö

# –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –≤—ã—Ö–æ–¥–æ–≤ —Å–∫—Ä—ã—Ç–æ–≥–æ —Å–ª–æ—è

hidden_input = np.dot(w_input_hidden, input_vector)
hidden_output = sigmoid(hidden_input)

# –í—ã—á–∏—Å–ª–µ–Ω–∏—è –≤—ã—Ö–æ–¥–∞ —Å–µ—Ç–∏

final_input = np.dot(w_hidden_output, hidden_output)
final_output = sigmoid(final_input)

print(f'–í—ã—Ö–æ–¥ —Å–µ—Ç–∏ (forward pass): {final_output}')


# 3. –¢—Ä—ë—Ö—Å–ª–æ–π–Ω–∞—è –Ω–µ–π—Ä–æ–Ω–Ω–∞—è —Å–µ—Ç—å

# –ò–¥–µ—è: –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Å–µ—Ç–∏ —Å —Ç—Ä–µ–º—è —Å–ª–æ—è–º–∏: –≤—Ö–æ–¥–Ω–æ–π, —Å—Ä–µ–¥–Ω–∏–π, –≤—ã—Ö–æ–¥–Ω–æ–π. –¢–∞–∫–æ–π –ø–æ–¥—Ö–æ–¥ –ø–æ–∑–≤–æ–ª—è–µ—Ç –º–æ–¥–µ–ª–∏ —Ä–µ—à–∞—Ç—å –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–µ –∑–∞–¥–∞—á–∏

# –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞: 3 –≤—Ö–æ–¥–∞, 4 —Å–∫—Ä—ã—Ç—ã—Ö –Ω–µ–π—Ä–æ–Ω–∞, 2 –≤—ã—Ö–æ–¥–Ω—ã—Ö –Ω–µ–π—Ä–æ–Ω–∞

def forward_pass ( input_vector, w_ih, w_ho ):
    hidden = sigmoid(np.dot( w_ih, input_vector) )
    output = sigmoid( np.dot (w_ho, hidden) )
    return output

# –ü—Ä–∏–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö –∏ –≤–µ—Å–æ–≤

input_data = np.array([0.6, 0.1, 0.8])
w_input_hidden = np.random.uniform(-0.5, 0.5, (4,3))
w_hidden_output = np.random.uniform(-0.5, 0.5, (2,4))

output = forward_pass(input_data, w_input_hidden, w_hidden_output)

print("–í—ã—Ö–æ–¥ —Ç—Ä—ë—Ö—Å–ª–æ–π–Ω–æ–π —Å–µ—Ç–∏:", output)

# 4. –û–±—É—á–µ–Ω–∏–µ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏ (Backpropagation)

# –ò–¥–µ—è: –ü–æ—Å–ª–µ –ø—Ä—è–º–æ–≥–æ –ø—Ä–æ—Ö–æ–¥–∞ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –æ—à–∏–±–∫–∞ –º–µ–∂–¥—É –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω—ã–º –∏ –∂–µ–ª–∞–µ–º—ã–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º.
# –ó–∞—Ç–µ–º, —Å –ø–æ–º–æ—â—å—é –æ–±—Ä–∞—Ç–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –æ—à–∏–±–∫–∏ –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É—é—Ç—Å—è –≤–µ—Å–∞ –ø–æ –ø—Ä–∞–≤–∏–ª—É –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω–æ–≥–æ —Å–ø—É—Å–∫–∞

# –û–±—É—á–∞—é—â–∏–π –ø—Ä–∏–º–µ—Ä –¥–ª—è –æ–¥–Ω–æ–≥–æ —à–∞–≥–∞ –æ–±—É—á–µ–Ω–∏—è

learning_rate = 0.1  # üîß –ó–∞–¥–∞—ë–º —Å–∫–æ—Ä–æ—Å—Ç—å –æ–±—É—á–µ–Ω–∏—è ‚Äî –Ω–∞—Å–∫–æ–ª—å–∫–æ —Å–∏–ª—å–Ω–æ –º–µ–Ω—è—Ç—å –≤–µ—Å–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ

target = np.array([0, 1])  # üéØ –¶–µ–ª–µ–≤–æ–π (–∂–µ–ª–∞–µ–º—ã–π) –≤—ã—Ö–æ–¥ ‚Äî –Ω–∞–ø—Ä–∏–º–µ—Ä, [0, 1] –æ–∑–Ω–∞—á–∞–µ—Ç "–≤—Ç–æ—Ä–æ–π –∫–ª–∞—Å—Å"

# === üîÅ –ü–†–Ø–ú–û–ô –ü–†–û–•–û–î (Forward Pass) ===

inputs = input_data.reshape(-1, 1)  # üîÑ –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤—Ö–æ–¥–Ω–æ–π –≤–µ–∫—Ç–æ—Ä –≤ —Å—Ç–æ–ª–±–µ—Ü (—Ä–∞–∑–º–µ—Ä n√ó1)

hidden_input = np.dot(w_input_hidden, inputs)      # üß† –°–∏–≥–Ω–∞–ª—ã –Ω–∞ —Å–∫—Ä—ã—Ç—ã–π —Å–ª–æ–π: –≤–∑–≤–µ—à–µ–Ω–Ω–∞—è —Å—É–º–º–∞ –≤—Ö–æ–¥–æ–≤
hidden_output = sigmoid(hidden_input)              # ‚ö° –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–∏–≥–º–æ–∏–¥—É ‚Äî –∞–∫—Ç–∏–≤–∞—Ü–∏—è —Å–∫—Ä—ã—Ç—ã—Ö –Ω–µ–π—Ä–æ–Ω–æ–≤

final_input = np.dot(w_hidden_output, hidden_output)  # üì° –°–∏–≥–Ω–∞–ª—ã –Ω–∞ –≤—ã—Ö–æ–¥–Ω–æ–π —Å–ª–æ–π: –∏–∑ —Å–∫—Ä—ã—Ç–æ–≥–æ
final_output = sigmoid(final_input)                   # ‚ö° –ê–∫—Ç–∏–≤–∞—Ü–∏—è –≤—ã—Ö–æ–¥–Ω—ã—Ö –Ω–µ–π—Ä–æ–Ω–æ–≤

# === ‚ùå –í–´–ß–ò–°–õ–ï–ù–ò–ï –û–®–ò–ë–ö–ò ===

error = target.reshape(-1, 1) - final_output  # ‚ùó –û—à–∏–±–∫–∞: –Ω–∞—Å–∫–æ–ª—å–∫–æ –≤—ã—Ö–æ–¥ —Å–µ—Ç–∏ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç –Ω—É–∂–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞

# === üìâ –û–ë–†–ê–¢–ù–û–ï –†–ê–°–ü–†–û–°–¢–†–ê–ù–ï–ù–ò–ï: –ì–†–ê–î–ò–ï–ù–¢–´ ===

# üîΩ –ì—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –≤—ã—Ö–æ–¥–Ω–æ–≥–æ —Å–ª–æ—è: –Ω–∞—Å–∫–æ–ª—å–∫–æ –Ω—É–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å –∫–∞–∂–¥—ã–π –≤—ã—Ö–æ–¥–Ω–æ–π –Ω–µ–π—Ä–æ–Ω
grad_output = error * final_output * (1 - final_output)  # —Ñ–æ—Ä–º—É–ª–∞ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ —Å–∏–≥–º–æ–∏–¥—ã

# üîß –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–µ—Å–æ–≤ –º–µ–∂–¥—É —Å–∫—Ä—ã—Ç—ã–º –∏ –≤—ã—Ö–æ–¥–æ–º
w_hidden_output += learning_rate * np.dot(grad_output, hidden_output.T)  # ŒîW = lr * Œ¥ * –≤—Ö–æ–¥^T

# üîΩ –û—à–∏–±–∫–∞, –∏–¥—É—â–∞—è –≤ —Å–∫—Ä—ã—Ç—ã–π —Å–ª–æ–π (–∫–∞–∫ –≤—ã—Ö–æ–¥–Ω—ã–µ –Ω–µ–π—Ä–æ–Ω—ã –ø–æ–≤–ª–∏—è–ª–∏ –Ω–∞ —Å–∫—Ä—ã—Ç—ã–µ)
hidden_error = np.dot(w_hidden_output.T, grad_output)

# üîΩ –ì—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è —Å–∫—Ä—ã—Ç–æ–≥–æ —Å–ª–æ—è
grad_hidden = hidden_error * hidden_output * (1 - hidden_output)

# üîß –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–µ—Å–æ–≤ –º–µ–∂–¥—É –≤—Ö–æ–¥–æ–º –∏ —Å–∫—Ä—ã—Ç—ã–º —Å–ª–æ–µ–º
w_input_hidden += learning_rate * np.dot(grad_hidden, inputs.T)

# ‚úÖ –§–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
print("–û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –≤–µ—Å–∞ (–ø—Ä–∏–º–µ—Ä –æ–±—É—á–µ–Ω–∏—è) –≤—ã–ø–æ–ª–Ω–µ–Ω—ã")



# 5. –ü—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ–π—Ä–æ–Ω–Ω–æ–π —Å–µ—Ç–∏ ¬´—Å –Ω—É–ª—è¬ª
# –ò–¥–µ—è: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –≤—Å—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É –∏ –∞–ª–≥–æ—Ä–∏—Ç–º –æ–±—É—á–µ–Ω–∏—è –±–µ–∑ –≥–æ—Ç–æ–≤—ã—Ö —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–æ–≤ ‚Äì
# –æ—Ç–ª–∏—á–Ω—ã–π —Å–ø–æ—Å–æ–± –ø–æ–Ω—è—Ç—å —Ä–∞–±–æ—Ç—É –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π –Ω–∞ –±–∞–∑–æ–≤–æ–º —É—Ä–æ–≤–Ω–µ.

# –ü—Ä–æ—Å—Ç–∞—è –Ω–µ–π—Ä–æ—Å–µ—Ç—å —Å –æ–¥–Ω–∏–º —Å–∫—Ä—ã—Ç—ã–º —Å–ª–æ–µ–º:

class SimpleNeuralNetwork:

    def __init__(self, input_size, hidden_size, output_size, learning_rate):
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –æ–±—É—á–µ–Ω–∏—è
        self.learning_rate = learning_rate

        # üé≤ –°–ª—É—á–∞–π–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤–µ—Å–æ–≤: –≤—Ö–æ–¥ -> —Å–∫—Ä—ã—Ç—ã–π —Å–ª–æ–π
        # –†–∞–∑–º–µ—Ä –º–∞—Ç—Ä–∏—Ü—ã: (–Ω–µ–π—Ä–æ–Ω–æ–≤ –≤ —Å–∫—Ä—ã—Ç–æ–º —Å–ª–æ–µ) √ó (–≤—Ö–æ–¥–æ–≤)
        self.w_input_hidden = np.random.uniform(-0.5, 0.5, (hidden_size, input_size))

        # üé≤ –°–ª—É—á–∞–π–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤–µ—Å–æ–≤: —Å–∫—Ä—ã—Ç—ã–π -> –≤—ã—Ö–æ–¥
        # –†–∞–∑–º–µ—Ä: (–≤—ã—Ö–æ–¥–æ–≤) √ó (–Ω–µ–π—Ä–æ–Ω–æ–≤ –≤ —Å–∫—Ä—ã—Ç–æ–º —Å–ª–æ–µ)
        self.w_hidden_output = np.random.uniform(-0.5, 0.5, (output_size, hidden_size))

    def forward(self, input_vector):
        # üîÑ –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤—Ö–æ–¥ –≤ —Å—Ç–æ–ª–±–µ—Ü
        self.input = input_vector.reshape(-1, 1)

        # üß† –°–∫—Ä—ã—Ç—ã–π —Å–ª–æ–π: –≤–∑–≤–µ—à–µ–Ω–Ω–∞—è —Å—É–º–º–∞ + —Å–∏–≥–º–æ–∏–¥–∞
        self.hidden = sigmoid(np.dot(self.w_input_hidden, self.input))

        # üß† –í—ã—Ö–æ–¥–Ω–æ–π —Å–ª–æ–π: —Å–Ω–æ–≤–∞ –≤–∑–≤–µ—à–µ–Ω–Ω–∞—è —Å—É–º–º–∞ + —Å–∏–≥–º–æ–∏–¥–∞
        self.output = sigmoid(np.dot(self.w_hidden_output, self.hidden))

        # üéØ –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
        return self.output

    def train(self, input_vector, target_vector):
        # üîÅ –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä—è–º–æ–π –ø—Ä–æ—Ö–æ–¥ (–ø–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –≤—ã–≤–æ–¥)
        output = self.forward(input_vector)

        # üéØ –¶–µ–ª–µ–≤–æ–π –æ—Ç–≤–µ—Ç –≤ –≤–∏–¥–µ —Å—Ç–æ–ª–±—Ü–∞
        target = target_vector.reshape(-1, 1)

        # ‚ùå –û—à–∏–±–∫–∞ –º–µ–∂–¥—É —Ü–µ–ª–µ–≤—ã–º –∏ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏–º –≤—ã—Ö–æ–¥–æ–º
        error = target - output

        # üîÅ –ì—Ä–∞–¥–∏–µ–Ω—Ç –æ—à–∏–±–∫–∏ –¥–ª—è –≤—ã—Ö–æ–¥–Ω–æ–≥–æ —Å–ª–æ—è
        grad_output = error * output * (1 - output)

        # üîß –û–±–Ω–æ–≤–ª—è–µ–º –≤–µ—Å–∞ —Å–∫—Ä—ã—Ç—ã–π -> –≤—ã—Ö–æ–¥–Ω–æ–π —Å–ª–æ–π
        self.w_hidden_output += self.learning_rate * np.dot(grad_output, self.hidden.T)

        # üß† –û—à–∏–±–∫–∞, –ø–µ—Ä–µ–¥–∞–Ω–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–æ –≤ —Å–∫—Ä—ã—Ç—ã–π —Å–ª–æ–π
        hidden_error = np.dot(self.w_hidden_output.T, grad_output)

        # üîÅ –ì—Ä–∞–¥–∏–µ–Ω—Ç –æ—à–∏–±–∫–∏ –¥–ª—è —Å–∫—Ä—ã—Ç–æ–≥–æ —Å–ª–æ—è
        grad_hidden = hidden_error * self.hidden * (1 - self.hidden)

        # üîß –û–±–Ω–æ–≤–ª—è–µ–º –≤–µ—Å–∞ –≤—Ö–æ–¥ -> —Å–∫—Ä—ã—Ç—ã–π —Å–ª–æ–π
        self.w_input_hidden += self.learning_rate * np.dot(grad_hidden, self.input.T)

# === üöÄ –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è ===

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–µ–π—Ä–æ—Å–µ—Ç—å: 3 –≤—Ö–æ–¥–∞, 4 —Å–∫—Ä—ã—Ç—ã—Ö –Ω–µ–π—Ä–æ–Ω–∞, 2 –≤—ã—Ö–æ–¥–∞
nn = SimpleNeuralNetwork(input_size=3, hidden_size=4, output_size=2, learning_rate=0.1)

# –ü—Ä–æ–≥–æ–Ω—è–µ–º –≤—Ö–æ–¥ –¥–æ –æ–±—É—á–µ–Ω–∏—è
print("–ù–∞—á–∞–ª—å–Ω—ã–π –≤—ã–≤–æ–¥ —Å–µ—Ç–∏:", nn.forward(np.array([0.6, 0.1, 0.8])).flatten())

# –û–±—É—á–∞–µ–º —Å–µ—Ç—å –Ω–∞ –æ–¥–Ω–æ–º –ø—Ä–∏–º–µ—Ä–µ —Å —Ü–µ–ª–µ–≤—ã–º –≤—ã—Ö–æ–¥–æ–º [1, 0]
nn.train(np.array([0.6, 0.1, 0.8]), np.array([1, 0]))

# –°–º–æ—Ç—Ä–∏–º, –∫–∞–∫ –∏–∑–º–µ–Ω–∏–ª—Å—è –≤—ã—Ö–æ–¥ –ø–æ—Å–ª–µ –æ–±—É—á–µ–Ω–∏—è
print("–í—ã–≤–æ–¥ —Å–µ—Ç–∏ –ø–æ—Å–ª–µ –æ–±—É—á–µ–Ω–∏—è:", nn.forward(np.array([0.6, 0.1, 0.8])).flatten())


